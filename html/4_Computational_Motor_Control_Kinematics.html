<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>4. Computational Motor Control: Kinematics</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="4. Computational Motor Control: Kinematics"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="fall 2012"/>
<meta name="author" content="Paul Gribble &amp; Dinant Kistemaker"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" type="text/css" href="mystyle.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
/**
 *
 * @source: http://orgmode.org/mathjax/MathJax.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 * Copyright (C) 2012  MathJax
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 */

/*
@licstart  The following is the entire license notice for the
JavaScript code below.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code below is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code below.
*/
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="http://www.gribblelab.org/compneuro/2_Modelling_Dynamical_Systems.html"> UP </a>
 |
 <a accesskey="H" href="http://www.gribblelab.org/compneuro/index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">4. Computational Motor Control: Kinematics</h1>



<hr/>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Introduction</a>
<ul>
<li><a href="#sec-1-1">One-joint Elbow Kinematic Model</a>
<ul>
<li><a href="#sec-1-1-1">Forward Kinematics</a></li>
<li><a href="#sec-1-1-2">Inverse Kinematics</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Two-joint arm</a>
<ul>
<li><a href="#sec-1-2-1">Forward Kinematics</a></li>
<li><a href="#sec-1-2-2">Inverse Kinematics</a></li>
<li><a href="#sec-1-2-3">The Jacobian</a></li>
<li><a href="#sec-1-2-4">Inverse Jacobian</a></li>
</ul>
</li>
<li><a href="#sec-1-3">The Redundancy Problem</a></li>
<li><a href="#sec-1-4">Computational Models of Kinematics</a>
<ul>
<li><a href="#sec-1-4-1">The Minimum-Jerk Hypothesis</a></li>
<li><a href="#sec-1-4-2">Minimum Endpoint Variance</a></li>
</ul>
</li>
<li><a href="#sec-1-5">Why are kinematic transformations important?</a></li>
</ul>
</li>
</ul>
</div>
</div>

<hr/>


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">


<p>
Here we will talk about kinematic models of the arm. We will start
with single-joint (elbow) models and progress to two-joint (shoulder,
elbow) and even three-joint (shoulder, elbow, wrist) arm models. First
we will talk about kinematic coordinate transformations. The goal is
to develop the equations for forward and inverse kinematic
transformations. <b>Forward kinematic equations</b> take us from intrinsic
to extrinsic variables, for example from joint angles to hand
position. So given a 2-element vector of shoulder and elbow angles
\((\theta_{1},\theta_{2})\), we can compute what the 2D location of the
hand is, in a cartesian coordinate system \((H_{x},H_{y})\). <b>Inverse kinematic equations</b> take us in the other direction, from extrinsic
variables to intrinsic variables, e.g. from hand coordinates to joint
angles.
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">One-joint Elbow Kinematic Model</h3>
<div class="outline-text-3" id="text-1-1">


<p>
Let's first consider a simple model of an arm movement. To begin with
we will model a single joint, the elbow joint. Our model will have a
Humerus bone (upper arm) and an Ulna bone (lower arm). Our model will
be a planar 2D model and so we will ignore pronation and supination of
the forearm, and therefore we'll ignore the Radius bone. The lower arm
will include the hand, and for now we will assume that the wrist joint
is fixed, i.e. it cannot move. For now let's even ignore muscles.
</p>

<div class="figure">
<p><img src="figs/elbow_kinematics.png" width="600px" align="center" alt="figs/elbow_kinematics.png" /></p>
<p>Schematic of a simple kinematic model of the elbow joint</p>
</div>

<p>
The intrinsic variable in our one-joint elbow model is simple the
elbow angle \(\theta\), and the extrinsic variable is the hand position
in cartesian coordinates, which is defined by two values,
\((H_{x},H_{y})\).
</p>

</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Forward Kinematics</h4>
<div class="outline-text-4" id="text-1-1-1">


<p>
What are the forward kinematic equations for our elbow model? We
simply need to recall our trigonometry from high school (remember
<a href="http://en.wikipedia.org/wiki/Trigonometry#Mnemonics">SOH-CAH-TOA</a>?):
</p>


\begin{eqnarray}
H_{x} &= &l \cos(\theta) \\
H_{y} &= &l \sin(\theta)
\end{eqnarray}

<p>
So if I told you that my lower arm (Ulna bone) is 0.45 metres long and
that my elbow angle is 35 degrees (remember to convert to radians
before using \(\sin()\) and \(\cos()\), and asked you where my hand is
located, you could compute this:
</p>


\begin{eqnarray}
H_{x} &= &l \cos(\theta) &= 0.45 \cos\left(\frac{35*\pi}{180}\right) = 0.37 m\\
H_{y} &= &l \sin(\theta) &= 0.45 \sin\left(\frac{35*\pi}{180}\right) = 0.26 m\\
\end{eqnarray}

<p>
So the hand position would be \((0.37,0.26)\) (measured in metres).
</p>
</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Inverse Kinematics</h4>
<div class="outline-text-4" id="text-1-1-2">


<p>
What about the inverse kinematics equations? If I give you the
position of my hand, and the length of my lower arm, how can you
compute my elbow joint angle? Remember <a href="http://en.wikipedia.org/wiki/Trigonometry#Mnemonics">SOH-CAH-TOA</a>: \(\tan()\) equals
opposite (O) over adjacent (A) which in our case is \(H_{y}\) over
\(H_{x}\) so:
</p>


\begin{equation}
\tan(\theta) = \frac{H_{y}}{H_{x}}
\end{equation}

<p>
and so:
</p>


\begin{equation}
\theta = \arctan \left( \frac{H_{y}}{H_{x}} \right)
\end{equation}

<p>
Remember, angles are measured in radians. There are \(2\pi\) radians in
360 degrees.
</p>
<p>
We can of course do more than compute single values, we can compute
entire trajectories. So for example if I gave you a recording of elbow
angles over time, for example sampled at 200 Hz (200 samples per
second) then using the forward kinematic equations you would be able
to plot a cartesian-space (e.g. top-down) trajectory of the hand path,
and vice-versa.
</p>



<pre class="src src-python"><span style="color: #af0000;"># make up an elbow trajectory (pretend this was recorded in an experiment)</span>
<span style="color: #af5f00;">t</span> = linspace(0,1,200)
<span style="color: #af5f00;">theta</span> = sin(2*pi*t/4)
figure()
subplot(2,3,(1,2))
plot(t,theta*180/pi)
xlabel(<span style="color: #87005f;">'TIME (sec)'</span>)
ylabel(<span style="color: #87005f;">'ELBOW ANGLE (deg)'</span>)
<span style="color: #af0000;"># compute hand position Hx,Hy</span>
<span style="color: #af5f00;">l</span> = 0.45
<span style="color: #af5f00;">Hx</span> = l * cos(theta)
<span style="color: #af5f00;">Hy</span> = l * sin(theta)
subplot(2,3,(4,5))
plot(t,Hx,<span style="color: #87005f;">'b-'</span>)
plot(t,Hy,<span style="color: #87005f;">'r-'</span>)
xlabel(<span style="color: #87005f;">'TIME (sec)'</span>)
ylabel(<span style="color: #87005f;">'HAND POSITION (m)'</span>)
legend((<span style="color: #87005f;">'Hx'</span>,<span style="color: #87005f;">'Hy'</span>),loc=<span style="color: #87005f;">'lower right'</span>)
subplot(2,3,(3,6))
plot((0,Hx[0]),(0,Hy[0]),<span style="color: #87005f;">'g-'</span>)
plot((0,Hx[-1]),(0,Hy[-1]),<span style="color: #87005f;">'r-'</span>)
plot(Hx[0:-1:10],Hy[0:-1:10],<span style="color: #87005f;">'k.'</span>)
xlabel(<span style="color: #87005f;">'X (m)'</span>)
ylabel(<span style="color: #87005f;">'Y (m)'</span>)
axis(<span style="color: #87005f;">'equal'</span>)
</pre>



<div class="figure">
<p><img src="figs/elbow_movement_kinematics.png" width="800px" align="center" alt="figs/elbow_movement_kinematics.png" /></p>
<p>Example elbow movement</p>
</div>

</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Two-joint arm</h3>
<div class="outline-text-3" id="text-1-2">


<p>
Let's introduce a shoulder joint as well:
</p>

<div class="figure">
<p><img src="figs/twojointarm_kinematics.png" width="600px" align="center" alt="figs/twojointarm_kinematics.png" /></p>
<p>Schematic of a simple kinematic model of a two-joint arm</p>
</div>


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Forward Kinematics</h4>
<div class="outline-text-4" id="text-1-2-1">


<p>
Now let's think about the forward and inverse kinematic equations to
go from intrinsic coordinates, joint angles \((\theta_{1},\theta_{2})\)
to extrinsic coordinates \((H_{x},H_{y})\). We will compute the elbow
joint position as an intermediate step.
</p>


\begin{eqnarray}
E_{x} &= &l_{1} \cos(\theta_{1})\\
E_{y} &= &l_{1} \sin(\theta_{1})\\
H_{x} &= &E_{x} + l_{2}\cos(\theta_{1}+\theta_{2})\\
H_{y} &= &E_{y} + l_{2}\sin(\theta_{1}+\theta_{2})\\
\end{eqnarray}

<p>
Now if I give you a set of shoulder and elbow joint angles
\((\theta_{1},\theta_{2})\), you can compute what my hand position
\((H_{x},H_{y})\) is.
</p>
<p>
We can visualize this mapping by doing something like the following:
decide on a range of shoulder angles and elbow angles that are
physiologically realistic, and sample that range equally in joint
space &hellip; then run those joint angles through the forward kinematics
equations to visualize how those equally-spaced joint angles
correspond to cartesian hand positions.
</p>



<pre class="src src-python"><span style="color: #af0000;"># Function to transform joint angles (a1,a2) to hand position (Hx,Hy)</span>
<span style="color: #af00ff;">def</span> <span style="color: #0000ff;">joints_to_hand</span>(a1,a2,l1,l2):
  Ex = l1 * cos(a1)
  Ey = l1 * sin(a1)
  Hx = Ex + (l2 * cos(a1+a2))
  Hy = Ey + (l2 * sin(a1+a2))
  <span style="color: #af00ff;">return</span> Ex,Ey,Hx,Hy

<span style="color: #af0000;"># limb geometry</span>
<span style="color: #af5f00;">l1</span> = 0.34 <span style="color: #af0000;"># metres</span>
<span style="color: #af5f00;">l2</span> = 0.46 <span style="color: #af0000;"># metres</span>

<span style="color: #af0000;"># decide on a range of joint angles</span>
<span style="color: #af5f00;">n1steps</span> = 10
<span style="color: #af5f00;">n2steps</span> = 10
<span style="color: #af5f00;">a1range</span> = linspace(0*pi/180, 120*pi/180, n1steps) <span style="color: #af0000;"># shoulder</span>
<span style="color: #af5f00;">a2range</span> = linspace(0*pi/180, 120*pi/180, n2steps)   <span style="color: #af0000;"># elbow</span>

<span style="color: #af0000;"># sample all combinations and plot joint and hand coordinates</span>
<span style="color: #af5f00;">f</span>=figure(figsize=(8,12))
<span style="color: #af00ff;">for</span> i <span style="color: #af00ff;">in</span> <span style="color: #5f5f87;">range</span>(n1steps):
  <span style="color: #af00ff;">for</span> j <span style="color: #af00ff;">in</span> <span style="color: #5f5f87;">range</span>(n2steps):
    subplot(2,1,1)
    plot(a1range[i]*180/pi,a2range[j]*180/pi,<span style="color: #87005f;">'r+'</span>)
    ex,ey,hx,hy = joints_to_hand(a1range[i], a2range[j], l1, l2)
    subplot(2,1,2)
    plot(hx, hy, <span style="color: #87005f;">'r+'</span>)
subplot(2,1,1)
xlabel(<span style="color: #87005f;">'Shoulder Angle (deg)'</span>)
ylabel(<span style="color: #87005f;">'Elbow Angle (deg)'</span>)
title(<span style="color: #87005f;">'Joint Space'</span>)
subplot(2,1,2)
xlabel(<span style="color: #87005f;">'Hand Position X (m)'</span>)
ylabel(<span style="color: #87005f;">'Hand Position Y (m)'</span>)
title(<span style="color: #87005f;">'Hand Space'</span>)
<span style="color: #af5f00;">a1</span> = a1range[n1steps/2]
<span style="color: #af5f00;">a2</span> = a2range[n2steps/2]
ex,ey,hx,hy = joints_to_hand(a1,a2,l1,l2)
subplot(2,1,1)
plot(a1*180/pi,a2*180/pi,<span style="color: #87005f;">'bo'</span>,markersize=5)
axis(<span style="color: #87005f;">'equal'</span>)
<span style="color: #af5f00;">xl</span> = get(get(f,<span style="color: #87005f;">'axes'</span>)[0],<span style="color: #87005f;">'xlim'</span>)
<span style="color: #af5f00;">yl</span> = get(get(f,<span style="color: #87005f;">'axes'</span>)[0],<span style="color: #87005f;">'ylim'</span>)
plot((xl[0],xl[1]),(a2*180/pi,a2*180/pi),<span style="color: #87005f;">'b-'</span>)
plot((a1*180/pi,a1*180/pi),(yl[0],yl[1]),<span style="color: #87005f;">'b-'</span>)
subplot(2,1,2)
plot((0,ex,hx),(0,ey,hy),<span style="color: #87005f;">'b-'</span>)
plot(hx,hy,<span style="color: #87005f;">'bo'</span>,markersize=5)
axis(<span style="color: #87005f;">'equal'</span>)
<span style="color: #af5f00;">xl</span> = get(get(f,<span style="color: #87005f;">'axes'</span>)[1],<span style="color: #87005f;">'xlim'</span>)
<span style="color: #af5f00;">yl</span> = get(get(f,<span style="color: #87005f;">'axes'</span>)[1],<span style="color: #87005f;">'ylim'</span>)
plot((xl[0],xl[1]),(hy,hy),<span style="color: #87005f;">'b-'</span>)
plot((hx,hx),(yl[0],yl[1]),<span style="color: #87005f;">'b-'</span>)
</pre>



<div class="figure">
<p><img src="figs/twojointarm_kinematics_workspace.png" width="600px" align="center" alt="figs/twojointarm_kinematics_workspace.png" /></p>
<p>Joint vs Hand Kinematics for Two Joint Arm</p>
</div>

<p>
Note that in the lower plot, the shoulder location is at the origin,
\((0,0)\). The blue crosshairs in each subplot correspond to the same
arm position &mdash; in joint space (top) and in cartesian hand space
(bottom).
</p>
<p>
We can note a few distinct features of this mapping between joint and
hand space. First, equal spacing across the workspace in joint space
does <i>not</i> correspond to equal spacing across the hand workspace,
especially near the outer edges of the hand's reach. Second, a square
workspace region in joint space corresponds to a really curved region
in hand space. These complexities reflect the fact that the mapping
between joint space and hand space is <i>non-linear</i>.
</p>
</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Inverse Kinematics</h4>
<div class="outline-text-4" id="text-1-2-2">


<p>
You can start to appreciate the sorts of problems the brain must face
when planning arm movements. If I want move my hand through a
particular hand path, what joint angles does that correspond to? We
must use inverse kinematics to determine this.
</p>
<p>
I will leave the inverse kinematics equations up to you to derive as
one of the steps in your assignment for this topic.
</p>
</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">The Jacobian</h4>
<div class="outline-text-4" id="text-1-2-3">


<p>
So far we have looked at kinematic equations for arm positions &mdash; joint
angular positions and hand cartesian positions. Here we look at
velocities (rate of change of position) in the two coordinate frames,
joint-space and hand-space.
</p>
<p>
How can we compute hand velocities \(\frac{dH}{dt}\) given
joint velocities \(\frac{d\theta}{dt}\)? If we can we
compute an intermediate term \(\frac{dH}{d\theta}\) then we
can apply the the <a href="http://en.wikipedia.org/wiki/Chain_rule">Chain Rule</a>:
</p>


\begin{equation}
\frac{dH}{dt} = \frac{dH}{d\theta} \frac{d\theta}{dt}
\end{equation}

<p>
This intermediate term is in fact known as the <b>Jacobian</b>
(<a href="http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant">Wikipedia:Jacobian</a>) matrix \(J(\theta)\) and is defined as:
</p>


\begin{equation}
J(\theta) = \frac{dH}{d\theta}
\end{equation}

<p>
and so:
</p>


\begin{equation}
\frac{dH}{dt} = J(\theta) \frac{d\theta}{dt}
\end{equation}

<p>
Note that the Jacobian is written as \(J(\theta)\) which means it is a
function of joint angles \(\theta\) &mdash; in other words, the four terms
in the Jacobian matrix (see below) change depending on limb
configuration (joint angles). This means the relationships between
joint angles and hand coordinates changes depending on where the limb
is in its workspace. We already have an idea that this is true, from
the figure above.
</p>
<p>
For the sake of notational brevity we will refer to hand
velocities as \(\dot{H}\) and joint velocities as \(\dot{\theta}\) and we
will omit (from the notation) the functional dependence of \(J\) on
\(\theta\):
</p>


\begin{equation}
\dot{H} = J \dot{\theta}
\end{equation}

<p>
The Jacobian is a matrix-valued function; you can think of it like a
vector version of the derivative of a scalar. The Jacobian matrix \(J\)
encodes relationships between changes in joint angles and changes in
hand positions.
</p>


\begin{equation}
J = \frac{dH}{d\theta} = \left[
  \begin{array}{cc} \frac{\partial H_{x}}{\partial \theta_{1}}, &\frac{\partial H_{x}}{\partial \theta_{2}}\\
                    \frac{\partial H_{y}}{\partial \theta_{1}}, &\frac{\partial H_{y}}{\partial \theta_{2}}
  \end{array} \right]
\end{equation}

<p>
For a system with 2 joint angles \(\theta = (\theta_{1},\theta_{2})\)
and 2 hand coordinates \(H = (H_{x},H_{y})\), the Jacobian \(J\) is a 2x2
matrix where each value codes the rate of change of a given hand
coordinate with respect the given joint coordinate. So for example the
term \(\frac{\partial H_{x}}{\partial \theta_{2}}\) represents the
change in the \(x\) coordinate of the hand given a change in the elbow
joint angle \(\theta_{2}\).
</p>
<p>
So how do we determine the four terms of \(J\)? We have to do calculus
and differentiate the equations for \(H_{x}\) and \(H_{y}\) with respect
to the joint angles \(\theta_{1}\) and \(\theta_{2}\). Fortunately we can
use a Python package for symbolic computation called <a href="http://sympy.org/en/index.html">SymPy</a> to help us
with the calculus. (you will have to install SymPy&hellip; on Ubuntu (or
any Debian-based GNU/Linux), just type <code>sudo apt-get install python-sympy</code>)
</p>



<pre class="src src-python"><span style="color: #af0000;"># import sympy</span>
<span style="color: #af00ff;">from</span> sympy <span style="color: #af00ff;">import</span> *
<span style="color: #af0000;"># define these variables as symbolic (not numeric)</span>
a1,a2,l1,l2 = symbols(<span style="color: #87005f;">'a1 a2 l1 l2'</span>)
<span style="color: #af0000;"># forward kinematics for Hx and Hy</span>
<span style="color: #af5f00;">hx</span> = l1*cos(a1) + l2*cos(a1+a2)
<span style="color: #af5f00;">hy</span> = l1*sin(a1) + l2*sin(a1+a2)
<span style="color: #af0000;"># use sympy diff() to get partial derivatives for Jacobian matrix</span>
<span style="color: #af5f00;">J11</span> = diff(hx,a1)
<span style="color: #af5f00;">J12</span> = diff(hx,a2)
<span style="color: #af5f00;">J21</span> = diff(hy,a1)
<span style="color: #af5f00;">J22</span> = diff(hy,a2)
<span style="color: #af00ff;">print</span> J11
<span style="color: #af00ff;">print</span> J12
<span style="color: #af00ff;">print</span> J21
<span style="color: #af00ff;">print</span> J22
</pre>



<pre class="example">In [12]: print J11
-l1*sin(a1) - l2*sin(a1 + a2)

In [13]: print J12
-l2*sin(a1 + a2)

In [14]: print J21
l1*cos(a1) + l2*cos(a1 + a2)

In [15]: print J22
l2*cos(a1 + a2)
</pre>


<p>
So now we have the four terms of the Jacobian:
</p>


\begin{equation}
J = \left[ \begin{array}{cc}
    -l_{1}\sin(\theta_{1}) - l_{2}\sin(\theta_{1} + \theta_{2}),
    &-l_{2}\sin(\theta_{1} + \theta_{2})\\
    l_{1}\cos(\theta_{1}) + l_{2}\cos(\theta_{1} + \theta_{2}),
    &l_{2}\cos(\theta_{1} + \theta_{2})
   \end{array} \right]
\end{equation}

<p>
and now we can write a Python function that returns the Jacobian, given a set of joint angles:
</p>



<pre class="src src-python"><span style="color: #af00ff;">def</span> <span style="color: #0000ff;">jacobian</span>(A,aparams):
   <span style="color: #87005f;">"""</span>
<span style="color: #87005f;">   Given joint angles A=(a1,a2)</span>
<span style="color: #87005f;">   returns the Jacobian matrix J(q) = dH/dA</span>
<span style="color: #87005f;">   """</span>
   l1 = aparams[<span style="color: #87005f;">'l1'</span>]
   l2 = aparams[<span style="color: #87005f;">'l2'</span>]
   dHxdA1 = -l1*sin(A[0]) - l2*sin(A[0]+A[1])
   dHxdA2 = -l2*sin(A[0]+A[1])
   dHydA1 = l1*cos(A[0]) + l2*cos(A[0]+A[1])
   dHydA2 = l2*cos(A[0]+A[1])
   J = matrix([[dHxdA1,dHxdA2],[dHydA1,dHydA2]])
   <span style="color: #af00ff;">return</span> J
</pre>


<p>
and now we can use the Jacobian to compute hand velocities, given joint angular velocities according to the equation from above:
</p>


\begin{equation}
\dot{H} = J \dot{\theta}
\end{equation}


<pre class="src src-python"><span style="color: #af5f00;">aparams</span> = {<span style="color: #87005f;">'l1'</span> : 0.3384, <span style="color: #87005f;">'l2'</span> : 0.4554}
<span style="color: #af5f00;">A</span> = array([45.0,90.0])*pi/180       <span style="color: #af0000;"># joint angles</span>
<span style="color: #af5f00;">Ad</span> = matrix([[-5.0],[3.0]])*pi/180  <span style="color: #af0000;"># joint velocities</span>
<span style="color: #af5f00;">J</span> = jacobian(A,aparams)
<span style="color: #af5f00;">Hd</span> = J*Ad
<span style="color: #af00ff;">print</span> Hd
</pre>



<pre class="example">[[ 0.03212204]
 [-0.00964106]]
</pre>


<p>
We can visualize the Jacobian by plotting velocity vectors in joint
space and the corresponding velocity vectors in hand space. See source
file <a href="code/jacobian_plots.py">jacobian_plots.py</a> for python code.
</p>

<div class="figure">
<p><img src="figs/jacobian_plots.png" width="700px" align="center" alt="figs/jacobian_plots.png" /></p>
<p>Visualizing the Jacobian</p>
</div>

<ul>
<li id="sec-1-2-3-1">Accelerations<br/>

<p>
We can also use the Jacobian to compute accelerations at the hand due
to accelerations at the joint, simply by differentiating our equations
with respect to time. Remember the equation for velocity:
</p>


\begin{equation}
\dot{H} = J \dot{\theta}
\end{equation}

<p>
for acceleration we just differentiate both sides with respect to
time:
</p>


\begin{equation}
\ddot{H} = \frac{d}{dt} \left(\dot{H}\right) = \frac{d}{dt} \left( J \dot{\theta} \right)
\end{equation}

<p>
and apply the <a href="http://en.wikipedia.org/wiki/Product_rule">Product Rule</a> from calculus:
</p>


\begin{equation}
\frac{d}{dt} \left( J \dot{\theta} \right) = 
                      \left[ J \left( \frac{d}{dt} \dot{\theta} \right) \right] +
                      \left[ \left( \frac{d}{dt} J\right) \dot{\theta} \right]
\end{equation}

<p>
simplifying further,
</p>


\begin{equation}
\ddot{H} = (J) (\ddot{\theta}) + (\dot{J}) (\dot{\theta})
\end{equation}

<p>
So if we have joint accelerations \(\ddot{\theta}\) and joint velocities
\(\dot{\theta}\), all we need is the Jacobian \(J\) and the time
derivative of the Jacobian \(\dot{J}\), and we can compute hand
accelerations \(\ddot{H}\).
</p>
<p>
How do we get \(\dot{J}\)? Again we can use SymPy, as above, and we get
the following: (I will just show the final Python function, not the
SymPy part):
</p>



<pre class="src src-python"><span style="color: #af00ff;">def</span> <span style="color: #0000ff;">jacobiand</span>(A,Ad,aparams):
<span style="color: #87005f;">"""</span>
<span style="color: #87005f;">Given joint angles A=(a1,a2) and velocities Ad=(a1d,a2d)</span>
<span style="color: #87005f;">returns the time derivative of the Jacobian matrix d/dt (J)</span>
<span style="color: #87005f;">"""</span>
<span style="color: #af5f00;">l1</span> = aparams[<span style="color: #87005f;">'l1'</span>]
<span style="color: #af5f00;">l2</span> = aparams[<span style="color: #87005f;">'l2'</span>]
<span style="color: #af5f00;">Jd11</span> = -l1*cos(A[0])*Ad[0] - l2*(Ad[0] + Ad[1])*cos(A[0] + A[1])
<span style="color: #af5f00;">Jd12</span> = -l2*(Ad[0] + Ad[1])*cos(A[0] + A[1])
<span style="color: #af5f00;">Jd21</span> = -l1*sin(A[0])*Ad[0] - l2*(Ad[0] + Ad[1])*sin(A[0] + A[1])
<span style="color: #af5f00;">Jd22</span> = -l2*(Ad[0] + Ad[1])*sin(A[0] + A[1])
<span style="color: #af5f00;">Jd</span> = matrix([[Jd11, Jd12],[Jd21, Jd22]])
<span style="color: #af00ff;">return</span> Jd
</pre>


<p>
Note that the time derivative of the Jacobian, \(\dot{J}\), is a
function of both joint angles \(\theta\) and joint velocities
\(\dot{\theta}\).
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Inverse Jacobian</h4>
<div class="outline-text-4" id="text-1-2-4">


<p>
We have seen how to compute hand velocities and accelerations given joint angles, velocities and accelerations&hellip; but what about inverse kinematics? How do we compute joint velocities given hand velocities? What about joint accelerations given hand accelerations?
</p>
<p>
Recall for velocities that:
</p>


\begin{equation}
J \dot{\theta} = \dot{H}
\end{equation}

<p>
To solve for \(\dot{\theta}\) we can simply multiply both sides of the
equation by the matrix inverse of the Jacobian:
</p>


\begin{equation}
\dot{\theta} = J^{-1}\dot{H}
\end{equation}

<p>
In Numpy you can compute the inverse of a matrix using the <code>inv()</code> function.
</p>
<p>
Similarly for accelerations, we can do the following:
</p>


\begin{equation}
\ddot{\theta} = J^{-1} \left[ \ddot{H} - \left( (\dot{J}) (\dot{\theta})  \right)  \right]
\end{equation}


</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">The Redundancy Problem</h3>
<div class="outline-text-3" id="text-1-3">


<p>
Notice something important (and unrealistic) about our simple
two-joint arm model. There is a one-to-one mapping between any two
joint angles \((\theta_{1},\theta_{2})\) and hand position
\((H_{x},H_{y})\). That is to say, a given hand position is <i>uniquely defined</i> by a single set of joint angles.
</p>
<p>
This is of course convenient for us in a model, and indeed many
empirical paradigms in sensory-motor neuroscience construct situations
where this is true, so that it's easy to go between intrinsic and
extrinsic coordinate frames.
</p>
<p>
This is not how it is in the real musculoskeletal system, of course,
where there is a <i>many-to-one mapping</i> from intrinsic to extrinsic
coordinates. The human arm has not just two mechanical <i>degrees of freedom</i> (independent ways in which to move) but seven. The shoulder
is like a ball-socket joint, so it can rotate 3 ways (roll, pitch,
yaw). The elbow can rotate a single way (flexion/extension). The
forearm, because of the geometry of the radius and ulna bones, can
rotate one way (pronation/supination), and the wrist joint can rotate
two ways (flexion/extension, and radial/ulnar deviation). This is to
say nothing about shoulder translation (the shoulder joint itself can
be translated up/down and fwd/back) and the many, many degrees of
freedom of the fingers.
</p>
<p>
With 7 DOF at the joint level, and only three cartesian degrees of
freedom at the hand (the 3D position of the hand) we have 4 extra
DOF. This means that there is a 4-dimensional "null-space" where joint
rotations within that 4D null space <i>have no effect on 3D hand position</i>. Another way of putting this is, there are an infinite
number of ways of configuring the 7 joints of the arm to reach a
single 3D hand position.
</p>
<p>
How does the CNS choose to plan and control movements with all of this
redundancy? This is known in the sensory-motor neuroscience literature
as the <i>Redundancy Problem</i>.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Computational Models of Kinematics</h3>
<div class="outline-text-3" id="text-1-4">



</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">The Minimum-Jerk Hypothesis</h4>
<div class="outline-text-4" id="text-1-4-1">


<p>
One of the early computational models of arm movement kinematics was
described by Tamar Flash and Neville Hogan. Tamar was a postdoc at MIT
at the time, working with Neville Hogan, a Professor there (as well as
with Emilio Bizzi, another Professor at MIT). Tamar is now a Professor
at the Weizmann Institute of Science in Rehovot, Israel.
</p>
<p>
For a long time, researchers had noted striking regularities in the
hand paths of multi-joint arm movements. Movements were smooth, with
unimodal, (mostly) symmetric velocity profiles (so-called
"bell-shaped" velocity profiles).
</p>
<ul>
<li>Morasso, P. (1981). Spatial control of arm movements. Experimental
  Brain Research, 42(2), 223-227.

</li>
<li>Abend, W., Bizzi, E., &amp; Morasso, P. (1982). Human arm trajectory
  formation. Brain: a journal of neurology, 105(Pt 2), 331.

</li>
<li>Atkeson, C. G., &amp; Hollerbach, J. M. (1985). Kinematic features of
  unrestrained vertical arm movements. The Journal of Neuroscience,
  5(9), 2318-2330.
</li>
</ul>


<p>
Flash and Hogan investigated these patterns in the context of
optimization theory &mdash; a theory proposing that the brain plans and
controls movements in an <i>optimal</i> way, where optimal is defined by a
specific task-related cost function. In other words, the brain chooses
movement paths and neural control signals that <i>minimize</i> some
objective cost function.
</p>
<ul>
<li>Todorov, E. (2004). Optimality principles in sensorimotor
  control. Nature neuroscience, 7(9), 907-915.

</li>
<li>Diedrichsen, J., Shadmehr, R., &amp; Ivry, R. B. (2010). The
  coordination of movement: optimal feedback control and
  beyond. Trends in cognitive sciences, 14(1), 31-39.
</li>
</ul>


<p>
Flash and Hogan wondered, at the kinematic level, what cost function
might predict the empirically observed patterns of arm movements?
</p>
<p>
They discovered that by minimizing the time integral of the square of
"jerk", a simple kinematic model predicted many of the regular
patterns seen empirically for arm movements of many kinds (moving from
one point to another, or even moving through via-points and moving
around obstacles). <a href="http://en.wikipedia.org/wiki/Jerk_(physics)">Jerk</a> is the rate of change (the derivative) of
acceleration, i.e. the second derivative of velocity, or the third
derivative of position. Essentially jerk is a measure of movement
smoothness. Whether or not it turns out that the brain is actually
interested in minimizing jerk in order to plan and control arm
movements (an explanatory model), the minimum-jerk model turns out to
be a good descriptive model that is able to predict kinematics of
multi-joint movement.
</p>
<ul>
<li>Hogan, N. (1984). An organizing principle for a class of voluntary
  movements. The Journal of Neuroscience, 4(11), 2745-2754.

</li>
<li>Flash, T. and Hogan, N. (1985) The coordination of arm movements: an
  experimentally confirmed mathematical model. J. Neurosci. 7:
  1688-1703.
</li>
</ul>



</div>

</div>

<div id="outline-container-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">Minimum Endpoint Variance</h4>
<div class="outline-text-4" id="text-1-4-2">


<p>
More recently, researchers have investigated how noise (variability)
in neural control signals affects movement kinematics. One hypothesis
stemming from this work is that the CNS plans and controls movements
in such a way as to minimize the variance of the endpoint (e.g. the
hand, for a point-to-point arm movement). The idea is that the effects
of so-called "signal-dependent noise" in neural control signals
accumulates over the course of a movement, and so the hypothesis is
that the CNS chooses specific time-varying neural control signals that
minimize the variability of the endpoint (e.g. hand), for example at
the final target location of a point-to-point movement.
</p>
<ul>
<li>Harris, C. M., &amp; Wolpert, D. M. (1998). Signal-dependent noise
  determines motor planning. Nature, 394(6695), 780-784.

</li>
<li>van Beers, R. J., Haggard, P., &amp; Wolpert, D. M. (2004). The role of
  execution noise in movement variability. Journal of Neurophysiology,
  91(2), 1050-1063.

</li>
<li>Iguchi, N., Sakaguchi, Y., &amp; Ishida, F. (2005). The minimum endpoint
  variance trajectory depends on the profile of the signal-dependent
  noise. Biological cybernetics, 92(4), 219-228.

</li>
<li>Churchland, M. M., Afshar, A., &amp; Shenoy, K. V. (2006). A central
  source of movement variability. Neuron, 52(6), 1085-1096.

</li>
<li>Simmons, G., &amp; Demiris, Y. (2006). Object grasping using the minimum
  variance model. Biological cybernetics, 94(5), 393-407.
</li>
</ul>



</div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Why are kinematic transformations important?</h3>
<div class="outline-text-3" id="text-1-5">


<p>
The many-to-one mapping issue is directly relevant to current key
questions in sensory-motor neuroscience. How does the nervous system
choose a single arm configuration when the goal is to place the hand
at a specific 3D location in space? Of course the <i>redundancy problem</i>
as it's known, is not specific to kinematics. We have many more
muscles than joints, and so the problem crops up again: how does the
CNS choose a particular set of time-varying muscle forces, to produce
a given set of joint torques? The redundancy problem keeps getting
worse as we go up the pipe: there are <i>many</i> more neurons than
muscles, and again, how does the CNS coordinate millions of neurons to
control orders-of-magnitude fewer muscles? These are key questions
that are still unresolved in modern sensory-motor neuroscience. Making
computational models where we can explicitly investigate these
coordinate transformations, and make predictions based on different
proposed theories, is an important way to address these kinds of
questions.
</p>
<p>
Another category of scientific question where modeling kinematic
transformations comes in handy, is related to <i>noise</i> (I don't mean
acoustic noise, i.e. loud noises, but random variability). It is known
that neural signals are "noisy". The many transformations that sit in
between neuronal control signals to muscles, and resulting hand
motion, are complex and nonlinear. How do noisy control signals
manifest in muscle forces, or joint angles, or hand positions? Are
there predictable patterns of variability in arm movement that can be
attributed to these coordinate transformations? If so, can we study
how the CNS deals with this, i.e. compensates for it (or not)?
</p>
<p>
This gives you a flavour for the sorts of questions one can begin to
address, when you have an explicit quantitative model of coordinate
transformations. There are many studies in arm movement control, eye
movements, locomotion, etc, that use this basic approach, combining
experimental data with predictions from computational models.
</p>
<ul>
<li>Scott, S. H., and G. E. Loeb. "The computation of position sense
  from spindles in mono-and multiarticular muscles." The Journal of
  neuroscience 14, no. 12 (1994): 7529-7540.

</li>
<li>Tweed, Douglas B., Thomas P. Haslwanter, Vera Happe, and Michael
  Fetter. "Non-commutativity in the brain." Nature 399, no. 6733
  (1999): 261-263.

</li>
<li>Loeb, E. P., S. F. Giszter, P. Saltiel and E. Bizzi, and
  F. A. Mussa-Ivaldi. "Output units of motor behavior: an experimental
  and modeling study." Journal of cognitive neuroscience 12, no. 1
  (2000): 78-97.

</li>
<li>Selen, Luc PJ, David W. Franklin, and Daniel M. Wolpert. "Impedance
  control reduces instability that arises from motor noise." The
  Journal of Neuroscience 29, no. 40 (2009): 12606-12616.
</li>
</ul>



<p>
[ next ]
</p></div>
</div>
</div>
</div>

<div id="postamble">
<hr />Paul Gribble &amp; Dinant Kistemaker | fall 2012<br>This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">work</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a><br><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
</div>
</body>
</html>
