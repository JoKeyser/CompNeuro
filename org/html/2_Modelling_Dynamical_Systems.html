<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>2. Modelling Dynamical Systems</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="2. Modelling Dynamical Systems"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="fall 2012"/>
<meta name="author" content="Paul Gribble &amp; Dinant Kistemaker"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" type="text/css" href="mystyle.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="http://www.gribblelab.org/compneuro/1_Dynamical_Systems.html"> UP </a>
 |
 <a accesskey="H" href="http://www.gribblelab.org/compneuro/index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">2. Modelling Dynamical Systems</h1>



<hr/>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Characterizing a System Using Differential Equations</a></li>
<li><a href="#sec-2">Integrating Differential Equations in Python/SciPy</a>
<ul>
<li><a href="#sec-2-1">The power of modelling and simulation</a></li>
<li><a href="#sec-2-2">Exercises</a></li>
</ul>
</li>
<li><a href="#sec-3">Lorenz Attractor</a></li>
<li><a href="#sec-4">Predator-Prey model</a>
<ul>
<li><a href="#sec-4-1">Exercises</a></li>
</ul>
</li>
<li><a href="#sec-5">Next steps</a></li>
</ul>
</div>
</div>

<hr/>


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Characterizing a System Using Differential Equations</h2>
<div class="outline-text-2" id="text-1">


<p>
A dynamical system such as the mass-spring system we saw before, can
be characterized by the relationship between state variables \(s\) and
their (time) derivatives \(\dot{s}\). How do we arrive at the correct
characterization of this relationship? The short answer is, we figure
it out using our knowledge of physics, or we are simply given the
equations by someone else. Let's look at a simple mass-spring system
again.
</p>

<div class="figure">
<p><img src="figs/spring-mass.png" height="200px" align="center" alt="figs/spring-mass.png" /></p>
<p>A spring with a mass attached</p>
</div>

<p>
We know a couple of things about this system. We know from <a href="http://en.wikipedia.org/wiki/Hooke's_law">Hooke's law</a>
of elasticity that the extension of a spring is directly and linearly
proportional to the load applied to it. More precisely, the force that
a spring applies in response to a perturbation from it's <i>resting length</i> (the length at which it doesn't generate any force), is
linearly proportional, through a constant \(k\), to the difference in
length between its current length and its resting length (let's call
this distance \(x\)). For convention let's assume positive values of \(x\)
correspond to lengthening the spring beyond its resting length, and
negative values of \(x\) correspond to shortening the spring from its
resting length.
</p>


\begin{equation}
F = -kx
\end{equation}

<p>
Let's decide that the <i>state variable</i> that we are interested in for
our system is \(x\). We will refer to \(x\) instead of \(s\) from now on to
denote our state variable.
</p>
<p>
We also know from <a href="http://en.wikipedia.org/wiki/Newton's_laws_of_motion">Newton's laws of motion</a> (specifically <a href="http://en.wikipedia.org/wiki/Newton's_laws_of_motion#Newton.27s_second_law">Newton's second law</a>) that the net force on an object is equal to its mass \(m\)
multiplied by its acceleration \(a\) (the second derivative of
position).
</p>


\begin{equation}
F = ma
\end{equation}

<p>
Instead of using \(a\) to denote acceleration let's use a different
notation, in terms of the spring's perturbed length \(x\). The rate of
change (velocity) is denoted \(\dot{x}\) and the rate of change of the
velocity (i.e. the acceleration) is denoted \(\ddot{x}\).
</p>


\begin{equation}
F = m \ddot{x}
\end{equation}

<p>
We also know that the mass is affected by two forces: the force due to
the spring (\(-kx\)) and also the gravitational force \(g\). So the
equation characterizing the <i>net forces</i> on the mass is
</p>


\begin{equation}
\sum{F} = m\ddot{x} = -kx + mg
\end{equation}

<p>
or just
</p>


\begin{equation}
m\ddot{x} = -kx + mg 
\end{equation}

<p>
This equation is a <i>second-order</i> differential equation, because the
highest state derivative is a <i>second derivative</i> (i.e. \(\ddot{x}\),
the second derivative, i.e. the acceleration, of \(x\)). The equation
specifies the relationship between the state variables (in this case a
single state variable \(x\)) and its derivatives (in this case a single
derivative, \(\ddot{x}\)).
</p>
<p>
The reason we want an equation like this, from a practical point of
view, is that we will be using numerical solvers in Python/Scipy to
<i>integrate</i> this differential equation over time, so that we can
<i>simulate</i> the behaviour of the system. What these solvers need is a
Python function that returns state derivatives, given current
states. We can re-arrange the equation above so that it specifies how
to compute the state derivative \(\ddot{x}\) given the current state
\(\ddot{x}\).
</p>


\begin{equation}
\ddot{x} = \frac{-kx}{m} + g
\end{equation}

<p>
Now we have what we need in order to simulate this system in
Python/Scipy. At any time point, we can compute the acceleration of
the mass by the formula above.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Integrating Differential Equations in Python/SciPy</h2>
<div class="outline-text-2" id="text-2">


<p>
Here is a Python function that we will be using to simulate the
mass-spring system. All it does, really, is compute the equation
above: what is the value of \(\ddot{x}\), given \(x\)? The one addition we
have is that we are going to keep track not just of one state variable
\(x\) but also its first derivative \(\dot{x}\) (the rate of change of
\(x\), i.e. velocity).
</p>



<pre class="src src-python"><span style="color: #af00ff;">def</span> <span style="color: #0000ff;">MassSpring</span>(state,t):
  <span style="color: #af0000;"># unpack the state vector</span>
  x = state[0]
  xd = state[1]

  <span style="color: #af0000;"># these are our constants</span>
  k = 2.5 <span style="color: #af0000;"># Newtons per metre</span>
  m = 1.5 <span style="color: #af0000;"># Kilograms</span>
  g = 9.8 <span style="color: #af0000;"># metres per second</span>

  <span style="color: #af0000;"># compute acceleration xdd</span>
  xdd = ((-k*x)/m) + g

  <span style="color: #af0000;"># return the two state derivatives</span>
  <span style="color: #af00ff;">return</span> [xd, xdd]
</pre>


<p>
Note that the function we wrote takes two arguments as inputs: <code>state</code>
and <code>t</code>, which corresponds to time. This is necessary for the
numerical solver that we will use in Python/Scipy. The <code>state</code>
variable is actually an <i>array</i> of two values corresponding to \(x\) and
\(\dot{x}\).
</p>
<p>
How does numerical integration (simulation) work? Here is a summary of the steps that a numerical solver takes. First, you have to provide the system with two things:
</p>
<ol>
<li>initial conditions (what are the initial states of the system?)
</li>
<li>a time vector over which to simulate
</li>
</ol>


<p>
Given this, the numerical solver will go through the following steps to simulate the system:
</p>
<ul>
<li>calculate state derivatives \(\ddot{x}\) at the initial time (\(t=0\))
  given the initial states \((x,\dot{x})\)
</li>
<li>estimate \(x(t+ \Delta t)\) using \(x(t=0)\), \(\dot{x}(t=0)\) and
  \(\ddot{x}(t=0)\)
</li>
<li>calculate \(\ddot{x}(t=t + \Delta t)\) from \(x(t=t + \Delta t)\) and
  \(\dot{x}(t=t + \Delta t)\)
</li>
<li>estimate \(x(t + 2 \Delta t)\) and \(\dot{x}(t + 2 \Delta t)\) using
  \(x(t=t + \Delta t)\), \(\dot{x}(t=t + \Delta t)\) and \(\ddot{x}(t=t +
  \Delta t)\)
</li>
<li>calculate \(\ddot{x}(t=t + 2\Delta t)\) from \(x(t=t + 2\Delta t)\) and
  \(\dot{x}(t=t + 2\Delta t)\)
</li>
<li>&hellip; etc
</li>
</ul>


<p>
In this way the numerical solver can esimate how the system states
\((x,\dot{x})\) unfold over time, given the initial conditions, and the
known relationship between state derivatives and system states. The
details of the "estimate" steps above are not something we are going
to dive into now. Suffice it to say that current estimation algorithms
are based on the work of two German mathematicians named <a href="http://en.wikipedia.org/wiki/Runge–Kutta_methods">Runge and Kutta</a> in the beginning of the 20th century. These numerical recipies
are readily available in Scipy (<a href="http://docs.scipy.org/doc/scipy/reference/integrate.html">docs here</a> (and in MATLAB, and other
numerical software) and are known as ODE solvers (ODE stands for
<i>ordinary differential equation</i>).
</p>
<p>
Here's how we would simulate the mass-spring system above. Launch
iPython with the <code>--pylab</code> argument (this automatically imports a
bunch of libraries that we will use, including plotting libraries).
</p>



<pre class="src src-python"><span style="color: #af00ff;">from</span> scipy.integrate <span style="color: #af00ff;">import</span> odeint

<span style="color: #af00ff;">def</span> <span style="color: #0000ff;">MassSpring</span>(state,t):
  <span style="color: #af0000;"># unpack the state vector</span>
  x = state[0]
  xd = state[1]

  <span style="color: #af0000;"># these are our constants</span>
  k = -2.5 <span style="color: #af0000;"># Newtons per metre</span>
  m = 1.5 <span style="color: #af0000;"># Kilograms</span>
  g = 9.8 <span style="color: #af0000;"># metres per second</span>

  <span style="color: #af0000;"># compute acceleration xdd</span>
  xdd = ((k*x)/m) + g

  <span style="color: #af0000;"># return the two state derivatives</span>
  <span style="color: #af00ff;">return</span> [xd, xdd]

<span style="color: #af5f00;">state0</span> = [0.0, 0.0]
<span style="color: #af5f00;">t</span> = arange(0.0, 10.0, 0.1)

<span style="color: #af5f00;">state</span> = odeint(MassSpring, state0, t)

plot(t, state)
xlabel(<span style="color: #87005f;">'TIME (sec)'</span>)
ylabel(<span style="color: #87005f;">'STATES'</span>)
title(<span style="color: #87005f;">'Mass-Spring System'</span>)
legend((<span style="color: #87005f;">'$x$ (m)'</span>, <span style="color: #87005f;">'$\dot{x}$ (m/sec)'</span>))
</pre>


<p>
<a href="code/mass_spring.py">mass_spring.py</a>
</p>
<p>
A couple of notes about the code. I have simply chosen, out of the
blue, values for the constants \(k\) and \(m\). The <a href="http://en.wikipedia.org/wiki/Gravitational_constant">gravitational constant</a>
\(g\) is of course known. I have also chosen to simulate the system for
10 seconds, and I have chosen a time <i>resolution</i> of 100 milliseconds
(0.1 seconds). We will talk later about the issue of what is an
appropriate time resolution for simulation.
</p>
<p>
You should see a plot like this:
</p>

<div class="figure">
<p><img src="figs/mass-spring-sim.png" height="400px" align="center" alt="figs/mass-spring-sim.png" /></p>
<p>Mass-Spring Simulation</p>
</div>

<p>
The blue line shows the position \(x\) of the mass (the length of the
spring) over time, and the green line shows the rate of change of \(x\),
in other words the velocity \(\dot{x}\), over time. These are the two
states of the system, simulated over time.
</p>
<p>
The way to interpret this simulation is, if we start the system at
\(x=0\) and \(\dot{x}=0\), and simulate for 10 seconds, this is how the
system would behave.
</p>

</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">The power of modelling and simulation</h3>
<div class="outline-text-3" id="text-2-1">


<p>
Now you can appreciate the power of mathematical models and
simulation: given a model that characterizes (to some degree of
accuracy) the behaviour of a system we are interested in, we can use
simulation to perform experiments <i>in simulation</i> instead of in
reality. This can be very powerful. We can ask questions of the model,
in simulation, that may be too difficult, or expensive, or time
consuming, or just plain impossible, to do in real-life empirical
studies. The degree to which we regard the results of simulations as
interpretable, is a direct reflection of the degree to which we
believe that our mathematical model is a reasonable characterization
of the behaviour of the real system.
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">Exercises</h3>
<div class="outline-text-3" id="text-2-2">


<ol>
<li>We have started the system at \(x=0\) which means that the spring is
   not stretched beyond its resting length (so spring force due to
   stretch should equal zero), and \(\dot{x}=0\), which means the
   spring's velocity is zero, i.e. it is not moving. Why does the
   simulation predict that the spring will begin stretching, then
   bouncing back and forth?

</li>
<li>What is the influence of the sign and magnitude of the stiffness
   parameter \(k\)?

</li>
<li>In physics, <a href="http://en.wikipedia.org/wiki/Damping">damping</a> can be used to reduce the magnitude of
   oscillations. Damping generates a force that is directly
   proportional to velocity (\(F = -b\dot{x}\)). Add damping to the
   mass-spring system and re-run the simulation. Specify the value of
   the damping constant \(b=-2.0\). What happens?

</li>
<li>What is the influence of the sign and magnitude of the damping
   coefficient \(b\)?

</li>
<li>Double the mass, and re-run the simulaton. What happens?

</li>
<li>How would you add an input force to the system?
</li>
</ol>



</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Lorenz Attractor</h2>
<div class="outline-text-2" id="text-3">


<p>
The <a href="http://en.wikipedia.org/wiki/Lorenz_system">Lorenz system</a> is a dynamical system that we will look at briefly,
as it will allow us to discuss several interesting issues around
dynamical systems. It is a system often used to illustrate <a href="http://en.wikipedia.org/wiki/Nonlinear_system">non-linear systems</a> theory and <a href="http://en.wikipedia.org/wiki/Chaos_theory">chaos theory</a>. It's sometimes used as a simple
demonstration of the <a href="http://en.wikipedia.org/wiki/Butterfly_effect">butterfly effect</a> (sensitivity to initial
conditions).
</p>
<p>
The Lorenz system is a simplified mathematical model for atmospheric
convection. Let's not worry about the details of what it represents,
for now the important things to note are that it is a system of three
<i>coupled</i> differential equations, and characterizes a system with
three state variables \((x,y,z\)).
</p>


\begin{eqnarray}
\dot{x} &= &\sigma(y-x)\\
\dot{y} &= &(\rho-z)x - y\\
\dot{z} &= &xy-\beta z
\end{eqnarray}

<p>
If you set the three constants \((\sigma,\rho,\beta)\) to specific
values, the system exhibits <i>chaotic behaviour</i>.
</p>


\begin{eqnarray}
\sigma &= &10\\
\rho &= &28\\
\beta &= &\frac{8}{3}
\end{eqnarray}

<p>
Let's implement this system in Python/Scipy. We have been given above
the three equations that characterize how the state derivatives
\((\dot{x},\dot{y},\dot{z})\) depend on \((x,y,z)\) and the constants
\((\sigma,\rho,\beta)\). All we have to do is write a function that
implements this, set some initial conditions, decide on a time array
to simulate over, and run the simulation using <code>odeint()</code>.
</p>



<pre class="src src-python"><span style="color: #af00ff;">from</span> scipy.integrate <span style="color: #af00ff;">import</span> odeint

<span style="color: #af00ff;">def</span> <span style="color: #0000ff;">Lorenz</span>(state,t):
  <span style="color: #af0000;"># unpack the state vector</span>
  x = state[0]
  y = state[1]
  z = state[2]

  <span style="color: #af0000;"># these are our constants</span>
  sigma = 10.0
  rho = 28.0
  beta = 8.0/3.0

  <span style="color: #af0000;"># compute state derivatives</span>
  xd = sigma * (y-x)
  yd = (rho-z)*x - y
  zd = x*y - beta*z

  <span style="color: #af0000;"># return the state derivatives</span>
  <span style="color: #af00ff;">return</span> [xd, yd, zd]

<span style="color: #af5f00;">state0</span> = [2.0, 3.0, 4.0]
<span style="color: #af5f00;">t</span> = arange(0.0, 30.0, 0.01)

<span style="color: #af5f00;">state</span> = odeint(Lorenz, state0, t)

<span style="color: #af0000;"># do some fancy 3D plotting</span>
<span style="color: #af00ff;">from</span> mpl_toolkits.mplot3d <span style="color: #af00ff;">import</span> Axes3D
<span style="color: #af5f00;">fig</span> = figure()
<span style="color: #af5f00;">ax</span> = fig.gca(projection=<span style="color: #87005f;">'3d'</span>)
ax.plot(state[:,0],state[:,1],state[:,2])
ax.set_xlabel(<span style="color: #87005f;">'x'</span>)
ax.set_ylabel(<span style="color: #87005f;">'y'</span>)
ax.set_zlabel(<span style="color: #87005f;">'z'</span>)
show()
</pre>


<p>
<a href="code/lorenz1.py">lorenz1.py</a>
</p>
<p>
You should see something like this:
</p>

<div class="figure">
<p><img src="figs/lorenz1.png" height="400px" align="center" alt="figs/lorenz1.png" /></p>
<p>Lorenz Attractor</p>
</div>

<p>
The three axes on the plot represent the three states \((x,y,z)\)
plotted over the 30 seconds of simulated time. We started the system
with three particular values of \((x,y,z)\) (I chose them arbitrarily),
and we set the simulation in motion. This is the trajectory, in
<i>state-space</i>, of the Lorenz system.
</p>
<p>
You can see an interesting thing&hellip; the system seems to have two
stable equilibrium states, or attractors: those circular paths. The
system circles around in one "neighborhood" in state-space, and then
flips over and circles around the second neighborhood. The number of
times it circles in a given neighborhood, and the time at which it
switches, displays chaotic behaviour, in the sense that they are
exquisitly sensitive to initial conditions.
</p>
<p>
For example let's re-run the simulation but change the initial
conditions. Let's change them by a very small amount, say
0.0001&hellip; and let's only change the \(x\) initial state by that very
small amount. We will simulate for 30 seconds.
</p>



<pre class="src src-python"><span style="color: #af5f00;">t</span> = arange(0.0, 30, 0.01)

<span style="color: #af0000;"># original initial conditions</span>
<span style="color: #af5f00;">state1_0</span> = [2.0, 3.0, 4.0]
<span style="color: #af5f00;">state1</span> = odeint(Lorenz, state1_0, t)

<span style="color: #af0000;"># rerun with very small change in initial conditions</span>
<span style="color: #af5f00;">delta</span> = 0.0001
<span style="color: #af5f00;">state2_0</span> = [2.0+delta, 3.0, 4.0]
<span style="color: #af5f00;">state2</span> = odeint(Lorenz, state2_0, t)

<span style="color: #af0000;"># animation</span>
fig,ax = subplots()
pb, = ax.plot(state1[:,0],state1[:,1],<span style="color: #87005f;">'b-'</span>,alpha=0.2)
xlabel(<span style="color: #87005f;">'x'</span>)
ylabel(<span style="color: #87005f;">'y'</span>)
p, = ax.plot(state1[0:10,0],state1[0:10,1],<span style="color: #87005f;">'b-'</span>)
pp, = ax.plot(state1[10,0],state1[10,1],<span style="color: #87005f;">'b.'</span>,markersize=10)
p2, = ax.plot(state2[0:10,0],state2[0:10,1],<span style="color: #87005f;">'r-'</span>)
pp2, = ax.plot(state2[10,0],state2[10,1],<span style="color: #87005f;">'r.'</span>,markersize=10)
<span style="color: #af5f00;">tt</span> = title(<span style="color: #87005f;">"%4.2f sec"</span> % 0.00)
<span style="color: #af0000;"># animate</span>
<span style="color: #af5f00;">step</span>=3
<span style="color: #af00ff;">for</span> i <span style="color: #af00ff;">in</span> <span style="color: #875f87;">xrange</span>(1,shape(state1)[0]-10,step):
  p.set_xdata(state1[10+i:20+i,0])
  p.set_ydata(state1[10+i:20+i,1])
  pp.set_xdata(state1[19+i,0])
  pp.set_ydata(state1[19+i,1])
  p2.set_xdata(state2[10+i:20+i,0])
  p2.set_ydata(state2[10+i:20+i,1])
  pp2.set_xdata(state2[19+i,0])
  pp2.set_ydata(state2[19+i,1])
  tt.set_text(<span style="color: #87005f;">"%4.2f sec"</span> % (i*0.01))
  draw()

<span style="color: #af5f00;">i</span> = 1939          <span style="color: #af0000;"># the two simulations really diverge here!</span>
<span style="color: #af5f00;">s1</span> = state1[i,:]
<span style="color: #af5f00;">s2</span> = state2[i,:]
<span style="color: #af5f00;">d12</span> = norm(s1-s2) <span style="color: #af0000;"># distance</span>
<span style="color: #af00ff;">print</span> (<span style="color: #87005f;">"distance = %f for a %f different in initial condition"</span>) % (d12, delta)
</pre>


<p>
<a href="code/lorenz2.py">lorenz2.py</a>
</p>



<pre class="example">distance = 32.757253 for a 0.000100 different in initial condition
</pre>


<p>
You should see an animation of the two state-space trajectories. For
convenience we are only plotting \(x\) vs \(y\) and ignoring \(z\). It turns
out that 3D animations are not trivial in matplotlib (there is a
library called mayavi that is excellent for 3D stuff).
</p>
<p>
The original simulation is shown in blue and the new one (in which the
initial condition of \(x\) was increased by 0.0001) in red. The two
follow each other quite closely for a long time, and then begin to
diverge at about the 16 second mark. At the end of the animation it
looks like this:
</p>

<div class="figure">
<p><img src="figs/lorenz2.png" height="400px" align="center" alt="figs/lorenz2.png" /></p>
<p>Lorenz Attractor</p>
</div>

<p>
At 19.39 seconds it looks like this:
</p>

<div class="figure">
<p><img src="figs/lorenz3.png" height="400px" align="center" alt="figs/lorenz3.png" /></p>
<p>Lorenz Attractor</p>
</div>

<p>
Note how the two systems are in different "neighborhoods" entirely!
</p>
<p>
At the end of the code above we compute the distance between the two
systems (the 3D distance between their respective \((x,y,z)\) positions
in state-space), and the distance is a whopping 32.76 units, for a
0.0001 difference in initial conditions.
</p>
<p>
This illustrates how systems with relatively simple differential
equations characterizing their behaviour, can turn out to be
exquisitely sensitive to initial conditions. Just imagine if the
initial conditions of your simulation were gathered from empirical
observations (like the weather, for example). Now imagine you use a
model simulation to predict whether it will be sunny (left-hand
"neighborhood" of the plot above) or thunderstorms (right-hand
"neighborhood"), 30 days from now. If the answer can flip between one
prediction and the other, based on a 1/10,000 different in
measurement, you had better be sure of your empirical measurement
instruments, when you make a prediction 30 days out! Actually this
won't even solve the problem, no matter how precise your
measurements. The point is that the system as a whole is very
sensitive to even tiny changes in initial conditions. This is why
short-term weather forecasts are relatively accurate, but forecasts
past a couple of days can turn out to be dead wrong.
</p>

</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Predator-Prey model</h2>
<div class="outline-text-2" id="text-4">


<p>
The <a href="http://en.wikipedia.org/wiki/Lotka–Volterra_equation">Lotka-Volterra equations</a> are two coupled first-order nonlinear
differential equations that are used to characterize the dynamics of
biological systems in which a predator population and a prey popuation
interact. The two populations develop over time according to these equations:
</p>


\begin{eqnarray}
\dot{x} &= &x(\alpha-\beta y)\\
\dot{y} &= &-y(\gamma - \sigma x)
\end{eqnarray}

<p>
where \(x\) is the number of prey (for example, rabbits), \(y\) is the
number of predators (e.g. foxes), and \(\dot{x}\) and \(\dot{y}\)
represent the growth rates (the rates of change over time) of the two
populations. The values \((\alpha,\beta,\gamma,\sigma)\) are parameters
(constants) that characterize different aspects of the two
populations.
</p>
<p>
Assumptions of this simple form of the model are:
</p>
<ol>
<li>prey find ample food at all times
</li>
<li>food supply of predators depends entirely on prey population
</li>
<li>rate of change of population is proportional to its size
</li>
<li>the environment does not change
</li>
</ol>


<p>
The parameters can be interepreted as:
</p>
<ul>
<li>\(\alpha\) is the natural growth rate of prey in the absence of predation
</li>
<li>\(\beta\) is the death rate per encounter of prey due to predation
</li>
<li>\(\sigma\) is related to the growth rate of predators
</li>
<li>\(\gamma\) is the natural death rate of predators in the absence of food (prey)
</li>
</ul>


<p>
Here is some example code showing how to simulate this system. Just as
before, we need to complete a few steps:
</p>
<ol>
<li>write a Python function that characterizes how the system's state
   derivatives are related to the system's states (this is given by
   the equations above)
</li>
<li>decide on values of the system parameters
</li>
<li>decide on values of the initial conditions of the system (the
   initial values of the states)
</li>
<li>decide on a time span and time resolution for simulating the system
</li>
<li>simulate! (i.e. use an ODE solver to integrate the differential
   equations over time)
</li>
<li>examine the states, typically by plotting them
</li>
</ol>


<p>
Here is some code:
</p>



<pre class="src src-python"><span style="color: #af00ff;">from</span> scipy.integrate <span style="color: #af00ff;">import</span> odeint

<span style="color: #af00ff;">def</span> <span style="color: #0000ff;">LotkaVolterra</span>(state,t):
  x = state[0]
  y = state[1]
  alpha = 0.1
  beta =  0.1
  sigma = 0.1
  gamma = 0.1
  xd = x*(alpha - beta*y)
  yd = -y*(gamma - sigma*x)
  <span style="color: #af00ff;">return</span> [xd,yd]

<span style="color: #af5f00;">t</span> = arange(0,500,1)
<span style="color: #af5f00;">state0</span> = [0.5,0.5]
<span style="color: #af5f00;">state</span> = odeint(LotkaVolterra,state0,t)
figure()
plot(t,state)
ylim([0,8])
xlabel(<span style="color: #87005f;">'Time'</span>)
ylabel(<span style="color: #87005f;">'Population Size'</span>)
legend((<span style="color: #87005f;">'x (prey)'</span>,<span style="color: #87005f;">'y (predator)'</span>))
title(<span style="color: #87005f;">'Lotka-Volterra equations'</span>)
</pre>


<p>
You should see a plot like this:
</p>

<div class="figure">
<p><img src="figs/lotkavolterra1.png" height="400px" align="center" alt="figs/lotkavolterra1.png" /></p>
<p>Lotka-Volterra Simulation</p>
</div>

<p>
We can also plot the trajectory of the system in <i>state-space</i> (much
like we did for the Lorenz system above):
</p>



<pre class="src src-python"><span style="color: #af0000;"># animation in state-space</span>
fig,ax = subplots()
pb, = ax.plot(state[:,0],state[:,1],<span style="color: #87005f;">'b-'</span>,alpha=0.2)
xlabel(<span style="color: #87005f;">'x (prey population size)'</span>)
ylabel(<span style="color: #87005f;">'y (predator population size)'</span>)
p, = ax.plot(state[0:10,0],state[0:10,1],<span style="color: #87005f;">'b-'</span>)
pp, = ax.plot(state[10,0],state[10,1],<span style="color: #87005f;">'b.'</span>,markersize=10)
<span style="color: #af5f00;">tt</span> = title(<span style="color: #87005f;">"%4.2f sec"</span> % 0.00)
<span style="color: #af0000;"># animate</span>
<span style="color: #af5f00;">step</span>=3
<span style="color: #af00ff;">for</span> i <span style="color: #af00ff;">in</span> <span style="color: #875f87;">xrange</span>(1,shape(state)[0]-10,step):
  p.set_xdata(state[10+i:20+i,0])
  p.set_ydata(state[10+i:20+i,1])
  pp.set_xdata(state[19+i,0])
  pp.set_ydata(state[19+i,1])
  tt.set_text(<span style="color: #87005f;">"%d steps"</span> % (i))
  draw()
</pre>


<p>
<a href="code/lotkavolterra.py">lotkavolterra.py</a>
</p>
<p>
You should see a plot like this:
</p>

<div class="figure">
<p><img src="figs/lotkavolterra2.png" height="400px" align="center" alt="figs/lotkavolterra2.png" /></p>
<p>Lotka-Volterra State-space plot</p>
</div>


</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1">Exercises</h3>
<div class="outline-text-3" id="text-4-1">


<ol>
<li>Increase the \(\alpha\) parameter and re-run the simulation. What
   happens and why?
</li>
<li>Set all parameters to 0.2. What happens and why?
</li>
<li>Try the following: \((\alpha,\beta,\gamma,\sigma)\) =
   (0.20, 0.20, 0.02, 0.0). What happens and why?
</li>
</ol>


</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Next steps</h2>
<div class="outline-text-2" id="text-5">


<p>
We have seen how to take a set of differential equations that
characterize the dynamics of a system, and implement them in Python,
and run a simulation of the behaviour of that system over time. In the
next topic, we will be applying this to models of single neurons, and
simulating the dynamics of voltage-gated ion channels, and examining
how these models predict spiking behaviour.
</p>
<p>
[ <a href="3_Modelling_Action_Potentials.html">next</a> ]
</p></div>
</div>
</div>

<div id="postamble">
<hr />Paul Gribble &amp; Dinant Kistemaker | fall 2012<br>This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">work</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a><br><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" /></a><br />
</div>
</body>
</html>
